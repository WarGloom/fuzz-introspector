#!/usr/bin/env python3
# Copyright 2026 Fuzz Introspector Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""Validate results generated by run_plugin_backend_perf.py."""

from __future__ import annotations

import argparse
import json
import os
from pathlib import Path
from typing import Any


def _load_json(path: str) -> Any:
    with open(path, "r", encoding="utf-8") as json_file:
        return json.load(json_file)


def _validate_result_entry(
    entry: dict[str, Any],
    require_analysis_key: bool,
) -> tuple[bool, list[str]]:
    errors: list[str] = []

    if entry.get("return_code") != 0:
        errors.append(f"return_code={entry.get('return_code')}")

    out_dir = entry.get("out_dir", "")
    if not out_dir or not isinstance(out_dir, str):
        errors.append("missing out_dir")
        return False, errors

    report_path = Path(out_dir) / "fuzz_report.html"
    summary_path = Path(out_dir) / "summary.json"

    if not report_path.is_file():
        errors.append("missing fuzz_report.html")

    if not summary_path.is_file():
        errors.append("missing summary.json")
    else:
        try:
            summary = _load_json(str(summary_path))
        except (OSError, json.JSONDecodeError) as err:
            errors.append(f"invalid summary.json: {err}")
            summary = {}

        if require_analysis_key:
            plugin_name = entry.get("plugin", "")
            analyses = summary.get("analyses", {})
            if not isinstance(analyses, dict):
                errors.append("summary['analyses'] is not a dictionary")
            elif plugin_name not in analyses:
                errors.append(f"summary missing analyses[{plugin_name}]")

    return not errors, errors


def main() -> int:
    parser = argparse.ArgumentParser()
    parser.add_argument("--results-json", required=True)
    parser.add_argument(
        "--require-analysis-key",
        action="store_true",
        help=("Require summary.json to contain analyses[plugin] for every run. "
              "Use only for plugins expected to emit JSON upserts."),
    )
    args = parser.parse_args()

    if not os.path.isfile(args.results_json):
        raise FileNotFoundError(args.results_json)

    payload = _load_json(args.results_json)
    if not isinstance(payload, list):
        raise ValueError("results json must be a list")

    failed_count = 0
    print(
        "plugin\tstatus\trc\treport\tsummary\telapsed_s\trss_kb\tcpu\tissues")
    for entry in payload:
        plugin_name = str(entry.get("plugin", ""))
        return_code = entry.get("return_code")
        metrics = entry.get("metrics", {}) if isinstance(
            entry.get("metrics", {}), dict) else {}
        out_dir = str(entry.get("out_dir", ""))
        report_exists = os.path.isfile(os.path.join(out_dir, "fuzz_report.html"))
        summary_exists = os.path.isfile(os.path.join(out_dir, "summary.json"))
        is_ok, errors = _validate_result_entry(
            entry, args.require_analysis_key)
        status = "OK" if is_ok else "FAIL"
        if not is_ok:
            failed_count += 1
        print(
            f"{plugin_name}\t{status}\t{return_code}\t{report_exists}\t{summary_exists}\t"
            f"{metrics.get('elapsed_seconds')}\t{metrics.get('max_rss_kb')}\t"
            f"{metrics.get('cpu_percent', '')}\t{' | '.join(errors)}")

    print(
        f"TOTAL={len(payload)} OK={len(payload) - failed_count} FAIL={failed_count}"
    )
    return 1 if failed_count else 0


if __name__ == "__main__":
    raise SystemExit(main())
